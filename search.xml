<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/08/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/08/22/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章"><a href="#这是我的第一篇文章" class="headerlink" title="这是我的第一篇文章"></a>这是我的第一篇文章</h2><h1 id="题目A"><a href="#题目A" class="headerlink" title="题目A"></a>题目A</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>给定一个长度为n的二进制数，构造一个排序网络，使除了给定二进制数不能达到非递减排序外其它长度为n的二进制数情况都能达到。</strong></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>若有多个1，那么找到第一个1的位置pos，构造以pos为i，其它1为j的排序网络，这样原二进制数就会因为此产生无效交换实现达不到非递减排序的目的。</strong></p><p><strong>其它情况相同合并处理，对除了pos位置的其它位置进行排序，此时排序后（对于长度为n的非给定的二进制数）可能出现pos为0，pos左边出现1的情况，那么我们就要把左边的1都往右移动一个位置；还有可能排序后pos为1，后面的数为0，此时要对pos位置的1进行调整后移，但不能移到最后否则给定的要求不能达到排序效果的原二进制数也被成功排序了。</strong></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：Ｏ（ｎ＾２）</strong></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*====================*/</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">#define debug(a) cout&lt;&lt;#a&lt;&lt;&quot;=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">#define int long long</span><br><span class="line">#define x1 x111111</span><br><span class="line">#define y1 y111111</span><br><span class="line">#define x0 x00000</span><br><span class="line">#define y0 y00000</span><br><span class="line">/*====================*/</span><br><span class="line">typedef long long LL;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">/*====================*/</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">/*====================*/</span><br><span class="line">bool multi=1;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    vector&lt;pair&lt;int,int&gt;&gt; res;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    s=&#x27; &#x27;+s;</span><br><span class="line">    int pos=1,cnt=0;</span><br><span class="line">    while(s[pos]!=&#x27;1&#x27;)&#123;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cnt+=s[i]==&#x27;1&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=pos+1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(s[i]==&#x27;1&#x27;) res.push_back(&#123;pos,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">        if(i==pos) continue;</span><br><span class="line">        for(int j=1;j&lt;i;j++)&#123;</span><br><span class="line">            if(j==pos) continue;</span><br><span class="line">            res.push_back(&#123;j,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=pos-1;i&gt;=1;i--) res.push_back(&#123;i,i+1&#125;);</span><br><span class="line">    for(int i=pos;i&lt;=n-cnt-1;i++)&#123;</span><br><span class="line">        res.push_back(&#123;i,i+1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res.size()&lt;&lt;endl;</span><br><span class="line">    for(int i=0;i&lt;res.size();i++)&#123;</span><br><span class="line">        cout&lt;&lt;res[i].first&lt;&lt;&#x27; &#x27;&lt;&lt;res[i].second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="line">    int TTT=1;</span><br><span class="line">    if(multi) cin&gt;&gt;TTT;</span><br><span class="line">    while(TTT--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目D"><a href="#题目D" class="headerlink" title="题目D"></a>题目D</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>有一个</strong>n<em>m*<em>的方格，每格上都有一块巧克力。Kelin(K)和Walk Alone(W)两人轮流吃巧克力，Kelin先手。每人每次选择一对数x,y，吃掉以</em></em>(1,1)<strong>为左下角，</strong>(x,y)<strong>为右上角的矩形的巧克力且每次必须至少吃到</strong>1<strong>个。吃到</strong>(n,m)<strong>的玩家败，问谁获胜。</strong></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>分情况讨论：</strong></p><p><strong>①当n&#x3D;1且m&#x3D;1时，显然W胜</strong></p><p><strong>②当n&#x3D;1且m≠1时，K第一次取走(1,1)到(1,m-1)，W只能取(n,m)，显然K胜；当n≠1且m&#x3D;1时同理。</strong></p><p><strong>③当n≠1且m≠1时，K第一次取走(1,1)，接下来W取走后有两种情况：剩下完整矩形；剩下缺角的矩形。前者情况下若剩下的完整矩形只剩一列或一行，则与②情况相同，否则继续取剩下矩形的左下角的一块方格；后者情况下，取走最下边若干行或最左边若干列，可使得矩形仍然变成缺左下一块角的矩形，最终会剩下2*2大小缺左下一个角的矩形，此时W只能取左上块或右下块，K取对应得另一块，显然K取胜。</strong></p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：O(1)</strong></p><p><strong>空间复杂度：O(1)</strong></p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void solve()&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    if(a==1&amp;&amp;b==1)  cout&lt;&lt;&quot;Walk Alone&quot;&lt;&lt;endl;</span><br><span class="line">    else cout&lt;&lt;&quot;Kelin&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目H"><a href="#题目H" class="headerlink" title="题目H"></a>题目H</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>给定两个长度为n的数组a,b，可以选择其中一个数组交换其中的两个数字，问经过至多一次操作后最小的</strong>\sum_{i&#x3D;1}^n \lvert a_i-b_i \rvert**.**</p><p><strong>1\le n\le 2*10^5,0\le \lvert a_i\rvert,\lvert b_i \rvert\le 10^{12}</strong></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>由于选择</strong>a,b<strong>数组的效果相同，我们规定只选</strong>a<strong>数组。</strong></p><p><strong>我们可以用原来的</strong>\sum_{i&#x3D;1}^n \lvert a_i-b_i \rvert<strong>减去交换这一操作的贡献来得到答案。</strong></p><p><strong>那么如何算交换这一操作带来的贡献？</strong><br><strong>首先，每一个</strong>a[i],b[i]<strong>都可以用一维坐标轴上的一条线段表示，线段的长度即</strong>\lvert a_i-b_i \rvert</p><p><strong>而一次交换操作，则是相当于将</strong>i,j<strong>对应两条线段的</strong>a[i],a[j]<strong>两点交换。</strong></p><p><strong>（1）（正序）当</strong>a[i]\le b[i]<strong>且</strong>a[j]\le b[j]<strong>(a[i]&gt;b[i]且a[j]&gt;b[j])情况原此类似，这里也一一画图解释)</strong></p><p><strong>①如下图所示为</strong>a[j]\le b[i]<strong>时和交换</strong>a[i],a[j]<strong>后的图，两线段和交换前后不变</strong></p><p><img src="file:///C:/Users/79906/AppData/Roaming/Typora/typora-user-images/image-20230719161656944.png?lastModify=1692692007" alt="image-20230719161656944"></p><p><strong>②</strong>a[j]&gt;b[i]<strong>情况下画图同理可得，两线段和交换前后不变。</strong></p><p><strong>（2）（反序）当</strong>a[i]&gt;b[i]<strong>且</strong>a[j]&lt;b[j]<strong>（</strong>a[i]\le b[i]且a[j]\ge b[j]<strong>)</strong></p><ul><li><strong>（重叠情况）如下图情况下，线段和减少了</strong>2<em>\lvert a[i]-a[j]\rvert*<em>，即两倍的重叠面积</em></em></li></ul><p><img src="file:///C:/Users/79906/AppData/Roaming/Typora/typora-user-images/image-20230719162945872.png?lastModify=1692692007" alt="image-20230719162945872"></p><p><strong>因为情况略多，画图不便，这里只讨论重叠情况下这一种情况，其它情况同理</strong></p><ul><li><strong>（不重叠情况）如下图，观察到交换前后，线段和增加了</strong>2*\lvert a[i]-a[j]\rvert</li></ul><p><img src="file:///C:/Users/79906/AppData/Roaming/Typora/typora-user-images/image-20230719163546608.png?lastModify=1692692007" alt="image-20230719163546608"></p><p><strong>同样情况略多，我们只演示了一种情况。</strong></p><p><strong>多次情况模拟后可总结：反序</strong>(a[i]-b[i])<em>(a[j]-b[j])&lt;0<strong>下的有重叠情况会使答案在原来情况下减小</strong>2</em>重叠部分的长度****</p><p><strong>因此我们只需找到反序重叠情况下最大的重叠部分的长度即可。</strong></p><p><strong>那么如何找：</strong></p><p><strong>我们先按照每个线段的左端点排序，再从左往右遍历每个线段。初始使cur为c[0],i从1开始遍历到n-1</strong></p><p><strong>①如果</strong>c[i].r&lt;&#x3D;cur[i].r<strong>且<strong>flag</strong>不相等又左端点递增即**c[i].l&gt;&#x3D;cur.l</strong>（i线段被cur线段包含，且反序），此时被包含的线段的长度即为重叠部分长度<strong>c[i].r-c[i].l</strong>，维护最大重叠部分长度overlap**</p><p><strong>②反之，</strong>c[i].r&gt;cur[i].r<strong>，若</strong>c[i].l&lt;cur.r<strong>，则有重叠部分</strong>cur.r-c[i].l<strong>，否则没有重叠部分，但也可以合并在</strong>cur.r-c[i].l<strong>中，因为此时</strong>cur.r-c[i].l&lt;0<strong>不会更新overlap，对结果无影响。</strong></p><p><strong>那么什么时候更新cur？</strong></p><p><strong>情况①中不需要更新cur，因为cur包含了c[i]，c[i+1]与cur的重叠部分只会比c[i]大。</strong></p><p><strong>情况②中需要更新cur，因为左端点递增，而c[i].r&gt;cur，接下来与c[i]的重叠部分只会比cur大。</strong></p><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：O(n)</strong></p><p><strong>空间复杂度：O(n)</strong></p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*====================*/</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">#define debug(a) cout&lt;&lt;#a&lt;&lt;&quot;=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">#define int long long</span><br><span class="line">#define x1 x111111</span><br><span class="line">#define y1 y111111</span><br><span class="line">#define x0 x00000</span><br><span class="line">#define y0 y00000</span><br><span class="line">/*====================*/</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line">/*====================*/</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">/*====================*/</span><br><span class="line">bool multi=0;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    int l,r;//线段的左右端点</span><br><span class="line">    bool flag;//记录a[i]&lt;b[i]还是a[i]&gt;b[i]</span><br><span class="line">//当两个线段的flag不同是即为反序，在此情况下找到两线段重叠部分长度</span><br><span class="line">    bool operator&lt;(const Node &amp;w) const&#123;</span><br><span class="line">        if(l!=w.l) return l&lt;w.l;</span><br><span class="line">        else return r&lt;w.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n+1),b(n+1);</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i];</span><br><span class="line">    int sum=0;//求不交换情况下的结果</span><br><span class="line">    vector&lt;Node&gt; c(n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=abs(a[i]-b[i]);</span><br><span class="line">        c[i-1]=&#123;min(a[i],b[i]),max(a[i],b[i]),a[i]&lt;b[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(c.begin(),c.end());</span><br><span class="line">    int overlap=0;//最大重叠部分的长度</span><br><span class="line">    Node cur=c[0];</span><br><span class="line">    for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">        if(c[i].r&lt;=cur.r)&#123;</span><br><span class="line">            if(cur.flag!=c[i].flag) overlap=max(overlap,c[i].r-c[i].l);//反序情况下更新最大重叠部分长度</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(cur.flag!=c[i].flag) overlap=max(overlap,cur.r-c[i].l);//反序情况下更新最大重叠部分长度</span><br><span class="line">            cur=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum-2*overlap&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="line">    int TTT=1;</span><br><span class="line">    if(multi) cin&gt;&gt;TTT;</span><br><span class="line">    while(TTT--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目J"><a href="#题目J" class="headerlink" title="题目J"></a>题目J</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>**Walk Alone 初始有 <strong>n</strong> 块钱，如果每次投 <strong>x</strong> 元，有一半的概率输掉这 <strong>x</strong> 元，另一半概率赢得 <strong>2x</strong> 元。现在 **</p><p><strong>Walk Alone 采取下述策略投注：</strong></p><ul><li><strong>如果上一把赢了，这一把投 <strong>x_i &#x3D; 1</strong> 元</strong></li><li><strong>如果上一把输了，这一把投 <strong>x_i &#x3D; 2x_{i-1}</strong> 元</strong></li></ul><p><strong>问 Walk Alone 有多大概率拿到 n + m 元离开。</strong>1 ≤ n, m ≤ 10^9**。  **</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>观察与模拟样例可知，令一个周期为“输输输</strong>\dots<strong>赢”，此时相当于在最开始的基础上赢了1元</strong></p><p><strong>（假设输了k次后赢，相当于</strong>-1,-2,-4,-8,-16,\dots,-2^{k-1},+2^{k}<strong>，最终赚1元）</strong></p><p><strong>而我们要从n元赢到n+m元，即需要m个周期。</strong></p><p><strong>那么我们只需要求</strong>n\sim n+m-1<strong>每个周期都赢的概率，即</strong>\prod_{i&#x3D;n}^{n+m-1}P(i)</p><p><strong>而每个i的P(i)怎么算呢？即从i赢到n+m的概率如何计算？</strong></p><p><strong>我们可以考虑i什么情况下不能赢到n+m：</strong></p><p><strong>可以发现，有本金才能投入，一个周期内输的次数是有限的</strong></p><p><strong>当输了一个周期内能输掉的最大次数k时候，则失败：</strong></p><p><strong>1+2+4+\dots+2^{k-1}\le i\Rightarrow 2^{k}-1\le i</strong>(注意：输一次是<strong>2^0</strong>，所以输k次是<strong>2^{k-1}</strong>)</p><p><strong>要求最大整数k，且k满足</strong>2^{k}-1\le i\Rightarrow 2^k\le i+1\Rightarrow k&#x3D;  \lfloor\log_2(i+1)\rfloor<strong>①</strong></p><p><strong>输的概率：</strong>\frac{1}{2^k}**<strong>赢的概率：</strong>1-\frac{1}{2^k}**</p><p><strong>而每个k对应的一块区间</strong>[2^k-1,2^{k+1}-2]<strong>的概率都是相同的，即</strong>2^k-1\le x(x∈[2^k-1,2^{k+1}-2])<strong>对应的最大k都相同</strong></p><p><strong>所以我们只需要对</strong>[n,n+m-1]<strong>分块，进行逐块求解即可。</strong></p><p><strong>那么找到k的左端点和右端点分别是</strong>l&#x3D;\lfloor\log_2(n+1)\rfloor<strong>和</strong>r&#x3D;\lfloor\log_2(n+m)\rfloor<strong>（由①式可知）</strong></p><p><strong>然后用i遍历</strong>[l,r]<strong>，每次对i对应的块整体用快速幂累乘块中数量length次赢的概率</strong>p_i&#x3D;1-\frac{1}{2^i}<strong>（注意l和r出块间数量从l开始r结束）</strong></p><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：</strong>遍历套快速幂</p><p><strong>logn(\log(n+m)-\log(n+1))</strong></p><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*====================*/</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">#define debug(a) cout&lt;&lt;#a&lt;&lt;&quot;=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">#define int long long</span><br><span class="line">#define x1 x111111</span><br><span class="line">#define y1 y111111</span><br><span class="line">#define x0 x00000</span><br><span class="line">#define y0 y00000</span><br><span class="line">/*====================*/</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line">/*====================*/</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">const int mod=998244353;</span><br><span class="line">/*====================*/</span><br><span class="line">bool multi=0;</span><br><span class="line"></span><br><span class="line">//a ^ b mod p</span><br><span class="line">int qpow(int a,int b,int p)&#123;</span><br><span class="line">    ll res=1%p;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1) res=res*a%p;</span><br><span class="line">        a=(long long)a*a%p;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int l=log2(n+1),r=log2(n+m);</span><br><span class="line">    int res=1;</span><br><span class="line">    int inv2=qpow(2,mod-2,mod);//费马小定理预处理2^&#123;-1&#125;%mod的值</span><br><span class="line">    for(int i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        int length=min(n+m-1,(1ll&lt;&lt;(i+1))-2)-max(n,(ll)(1ll&lt;&lt;i)-1)+1;//块间数量</span><br><span class="line">        //l对应块的左端点需大于等于n+m-1，r对应块的右端点需小于等于n，我这里直接整体都取min和max了</span><br><span class="line">        res=res*qpow(((1-qpow(inv2,i,mod))%mod+mod)%mod,length,mod)%mod;</span><br><span class="line">        //用到了两次快速幂：1-1/2^k,累乘块长度个概率</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="line">    int TTT=1;</span><br><span class="line">    if(multi) cin&gt;&gt;TTT;</span><br><span class="line">    while(TTT--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目K"><a href="#题目K" class="headerlink" title="题目K"></a>题目K</h1><h2 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>给定一个无向图</strong>G(n, m)<strong>，可以将其中任意一条边用两条边替换，每条边的长度都为</strong>1<strong>，可以操作任意多次（也可以不操作）。问经过这</strong><br><strong>样处理之后，从 1 号节点出发，至多走 k 步最多可以到多少个节点。</strong><br>**数据范围： <strong>1 ≤ n ≤ 10^5， 1 ≤ m ≤ 2 × 10^5， 1 ≤ k ≤ 10^9</strong>。  **</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>首先，我们要知道****bfs树</strong>的概念，bfs树就是通过bfs从一个指定为树根开始遍历一个图得到的树形结构，既然是树形结构，就没有环。</p><p><strong>那么如何构建bfs树？（因为本题求距离1小于等于k的结点数，所以我这里就以1为根节点构建距离1小于等于k的所有结点形成的树）</strong></p><p><strong>从树根开始做bfs，每一个u通过一条边edge连向v，如果v第一次被更新则这条边为bfs树边，这个点也被加到bfs树结点中，不满足树需要的条件是结束。</strong></p><p><strong>显然，****我们要探究的是分裂哪些边？如何选择？</strong></p><p><strong>假设k&#x3D;1e9,如果我们选择分裂与1相邻的边，那么原来结点1连向的点如果有多个边连向其它点，那么这些贡献就会损失，由此可推出应该尽可能保留原有的距离1小于等于k的点。——①</strong></p><p><strong>结论：</strong></p><ul><li><strong>通过分析发现，我们应该保留原来可以在k步内能到达的点，而去分裂这些点之间多余的边，即删去这些边仍能到达这些点，这些边即bfs树结点之间的非bfs树边。</strong></li></ul><p><strong>如下图，假设最上面的顶点为1，红色即为无用边，删去后所有点与根节点的最短距离不变且最短距离所在路径仍存在。</strong></p><p><img src="file:///C:/Users/79906/AppData/Roaming/Typora/typora-user-images/image-20230719211128036.png?lastModify=1692692007" alt="image-20230719211128036"></p><p><img src="file:///C:/Users/79906/AppData/Roaming/Typora/typora-user-images/image-20230719212009390.png?lastModify=1692692007" alt="image-20230719212009390"></p><ul><li><strong>情况2，bfs树的叶子结点如果没有连向bfs树其它结点的非bfs树边，则在这个点与它的父节点之间分裂边</strong><br><strong>（上面①处分析了损失贡献的分裂边损失贡献的原因，而叶子结点与它的父节点之间分裂边不会损失贡献）</strong></li></ul><p><strong>总而言之：bfs树直接解决了分裂哪些边的问题。①所有bfs树结点之间的非bfs树边②bfs树的叶子节点与它的父节点之间的边且该叶子节点不能有一条连向bfs树结点的非bfs树边</strong></p><h2 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><strong>时间复杂度：O(mlogm)（遍历所有边m，标记bfs树边使用了map，每次操作logm）</strong></p><h2 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*====================*/</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">#define debug(a) cout&lt;&lt;#a&lt;&lt;&quot;=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">#define int long long</span><br><span class="line">#define x1 x111111</span><br><span class="line">#define y1 y111111</span><br><span class="line">#define x0 x00000</span><br><span class="line">#define y0 y00000</span><br><span class="line">/*====================*/</span><br><span class="line">typedef long long ll;</span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line">/*====================*/</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">/*====================*/</span><br><span class="line">bool multi=0;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    int n,m,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; edge(n+1);//bool用来标记是否是bfs树边</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;pair&lt;int,int&gt;,bool&gt; mp;//边是否是bfs树边</span><br><span class="line">    vector&lt;int&gt; dist(n+1,-1),bfsver,pre(n+1);</span><br><span class="line">    //dist存结点到根节点1的距离，bfsver存储bfs树结点，pre存储每个bfs树点的父节点</span><br><span class="line">    vector&lt;bool&gt; st(n+1);//标记是否是bfs树上的点</span><br><span class="line">    st[1]=true;</span><br><span class="line">    bfsver.push_back(1);//1是bfs树点</span><br><span class="line">    dist[1]=0;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(1);</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dist[u]==k) break;//只求距离根节点小于等于k部分的树</span><br><span class="line">        for(auto v:edge[u])&#123;</span><br><span class="line">            if(dist[v]!=-1) continue;</span><br><span class="line">            q.push(v);</span><br><span class="line">            mp[&#123;min(u,v),max(u,v)&#125;]=true;</span><br><span class="line">            //为了降低时间复杂度，所以我直接用&#123;min(u,v),max(u,v)&#125;来同时表示双向边都是bfs树边</span><br><span class="line">            dist[v]=dist[u]+1;</span><br><span class="line">            pre[v]=u;</span><br><span class="line">            st[v]=true;</span><br><span class="line">            bfsver.push_back(v);//将bfs树点加入遇到bfsver中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int res=(int)bfsver.size();//bfs树上的点都保留，这些点都会是答案的一部分</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;bfsver.size();i++)&#123;</span><br><span class="line">        int u=bfsver[i];</span><br><span class="line">        bool is_cal=0;</span><br><span class="line">        bool is_leaf=1;</span><br><span class="line">        for(auto v:edge[u])&#123;</span><br><span class="line">            bool flag=mp[&#123;min(u,v),max(u,v)&#125;];</span><br><span class="line">            if(st[v]&amp;&amp;!flag)&#123;//如果这个bfs树点通过非bfs树边连向了bfs树点，那么这条边可以分裂</span><br><span class="line">                res+=k-dist[u];</span><br><span class="line">                is_cal=1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(pre[v]==u)&#123;</span><br><span class="line">                is_leaf=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!is_cal&amp;&amp;is_leaf&amp;&amp;u!=1)&#123;</span><br><span class="line">            //如果这个点是叶子结点且没有通过非bfs树边连向其它bfs树点，则这个点和它的父节点之间的边可以分裂</span><br><span class="line">            res+=k-dist[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="line">    int TTT=1;</span><br><span class="line">    if(multi) cin&gt;&gt;TTT;</span><br><span class="line">    while(TTT--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目M"><a href="#题目M" class="headerlink" title="题目M"></a>题目M</h1><h2 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>给定两个杯子的容积a,b，你可以进行这四种操作：</strong></p><ul><li><strong>将其中一个杯子装满水</strong></li><li><strong>倒走其中一个杯子中的所有水</strong></li><li><strong>喝掉其中一个杯子的所有水</strong></li><li><strong>将尽可能多的水从其中一个杯子转移到另一个杯子，保证不溢出</strong></li></ul><p><strong>问能喝到c单位水的体积需要的最少操作次数。</strong></p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>设喝a水杯和b水杯的次数分别为x,y，得：</strong>ax+by&#x3D;c</p><p><strong>根据裴蜀定理，若</strong>gcd(a,b)|c<strong>，那么有解，否则无解输出-1</strong></p><p><strong>若有解，讨论x,y的正负性与操作次数的关系。</strong></p><ul><li><em><em>当x≥0且y≥0，每次喝水即倒入和喝水两次操作，结果为2</em>(x+y)</em>*</li><li><em><em>令a&lt;b，剩下x&lt;0且y&gt;0一种情况,每次喝水先倒入b，再倒入倒出多次a，再喝掉b中的水，但最后一次不需要倒走a中的水，所以结果为2</em>|x-y|-1</em>*</li></ul><p><strong>讨论x,y的绝对值最小的四种情况即可。</strong></p><h2 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>**时间复杂度:**O(Tlogx)</p><h2 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">/*====================*/</span><br><span class="line">#define endl &#x27;\n&#x27;</span><br><span class="line">#define debug(a) cout&lt;&lt;#a&lt;&lt;&quot;=&quot;&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">#define int long long</span><br><span class="line">#define x1 x111111</span><br><span class="line">#define y1 y111111</span><br><span class="line">#define x0 x00000</span><br><span class="line">#define y0 y00000</span><br><span class="line">/*====================*/</span><br><span class="line">typedef long long LL;</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">/*====================*/</span><br><span class="line">const double eps=1e-8;</span><br><span class="line">/*====================*/</span><br><span class="line">bool multi=1;</span><br><span class="line"></span><br><span class="line">//返回gcd(a,b)</span><br><span class="line">int exgcd(int a,int b,int &amp;x,int &amp;y)&#123;</span><br><span class="line">    if(!b)&#123;</span><br><span class="line">        x=1,y=0;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    int d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    int x0,y0;</span><br><span class="line">    int d=exgcd(a,b,x0,y0);</span><br><span class="line">    if(c%d!=0)&#123;//裴蜀定理，不能整除表示无解</span><br><span class="line">        cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int x1=x0*c/d,y1=y0*c/d;</span><br><span class="line">    int t1=abs(b/d),t2=a/d;</span><br><span class="line">    //枚举x，y的绝对值最小的四种情况。</span><br><span class="line">    //x为最小非负数</span><br><span class="line">    int x=(x1%t1+t1)%t1;</span><br><span class="line">    int y=(c-a*x)/b;</span><br><span class="line">    int res=(x&gt;=0&amp;&amp;y&gt;=0)?2*(x+y):2*abs(x-y)-1;</span><br><span class="line">    //x为最大负数</span><br><span class="line">    x=(x1%t1+t1)%t1-t1;</span><br><span class="line">    y=(c-a*x)/b;</span><br><span class="line">    res=min(res,(x&gt;=0&amp;&amp;y&gt;=0)?2*(x+y):2*abs(x-y)-1);</span><br><span class="line">    //y为最小非负数</span><br><span class="line">    y=(y1%t2+t2)%t2;</span><br><span class="line">    x=(c-b*y)/a;</span><br><span class="line">    res=min(res,(x&gt;=0&amp;&amp;y&gt;=0)?2*(x+y):2*abs(x-y)-1);</span><br><span class="line">    //y为最大负数</span><br><span class="line">    y=(y1%t2+t2)%t2-t2;</span><br><span class="line">    x=(c-b*y)/a;</span><br><span class="line">    res=min(res,(x&gt;=0&amp;&amp;y&gt;=0)?2*(x+y):2*abs(x-y)-1);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main()&#123;</span><br><span class="line">    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span><br><span class="line">    int TTT=1;</span><br><span class="line">    if(multi) cin&gt;&gt;TTT;</span><br><span class="line">    while(TTT--)&#123;</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
